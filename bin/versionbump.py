#! /usr/bin/env python

# Imports

from argparse import ArgumentParser, RawDescriptionHelpFormatter
from datetime import datetime
import os
import semver
from string import Template
import sys

# Administrivia

__author__ = "Shawn Davis <shawn@ptltd.co>"
__command__ = os.path.basename(sys.argv[0])
__date__ = "2016-10-31"
__version__ = "0.9.1-d"

# Constants

EXIT_OK = 0
EXIT_USAGE = 1
EXIT_INPUT = 2
EXIT_ENV = 3
EXIT_OTHER = 4

HELP = """
#### When to Use

Generally, you want to increment the version number immediately after checking
out a release branch. However, you may wish to bump the version any time
during development, especially during early development where the MINOR
and PATCH versions are changing frequently.

Here is an example workflow:

    # Get the current version and check out the next release.
    versionbump myproject; # get the current version, example 1.2
    git checkout -b release-1.3;

    # Bump automatically sets the next minor version with a status of d.
    versionbump myproject -m -s d;

    # Commit the bump.
    git commit -am "Version Bump";

    # Go do the final work for the release.
    # ...

    # Merge the release.
    git checkout master;
    git merge --no-ff release-1.3;
    git tag -a 1.3;

    # Merge back to development.
    git checkout development;
    git merge --no-ff release-1.3;

#### Semantic Versioning

This utility makes use of [Semantic Versioning](semver.org). From the
documentation:

1. MAJOR version when you make incompatible API changes,
2. MINOR version when you add functionality in a backwards-compatible manner,
   and
3. PATCH version when you make backwards-compatible bug fixes.

Additional labels for pre-release and build metadata are available as
extensions to the MAJOR.MINOR.PATCH format.

**Status**

We define the following status codes:

- x Prototype, experimental. Use at your own risk.
- d Development. Unstable, untested.
- a Feature complete.
- b Ready for testing and QA.
- r Release candidate.
- o Obsolete, deprecated, or defect. End of life.

You may of course use whatever status you like.

#### Release Versus Version

**Release**

A *release* is a collection of updates representing a new version of the
product. A release is represented by the full string of MAJOR.MINOR.PATCH,
and may optionally include the status and build until the release is live.

The release is probably never displayed to Customers or Users.

**Version**

A *version* represents a specific state of the product. The version is
represented by the MAJOR.MINOR string of the release.

The version may be shown to Customers or Users.

"""

NOW = datetime.now()

PROJECT_HOME = os.environ.get("PROJECT_HOME", "~/Work")

TEMPLATE = """# Generated by versionbump.py $now
major = $major
minor = $minor
patch = $patch
status = "$prerelease"
build = "$build"
name = "$name"


def get_release():
    r = "%s.%s.%s" % (major, minor, patch)

    if status:
        r += "-%s" % status

    return r


def get_version():
    return "%s.%s" % (major, minor)


RELEASE = get_release()
VERSION = get_version()

"""

VERSION_PY_LOCATIONS = (
    os.path.join("%(project_root)s", "version.py"),
    os.path.join("%(project_root)s", "%(project_name)s", "version.py"),
    os.path.join("%(project_root)s", "source", "main", "version.py"),
)

# Functions


def main():
    """Increment the version number immediately after checking out a release branch."""

    description = main.__doc__

    # Define options and arguments.
    parser = ArgumentParser(description=description, epilog=HELP, formatter_class=RawDescriptionHelpFormatter)

    parser.add_argument(
        "project_name",
        help="The name of the project. Typically, the directory name in which the project is stored."
    )

    parser.add_argument(
        "string",
        help="The specific release string to assign.",
        nargs="?"
    )

    parser.add_argument(
        "-b=",
        "--build=",
        dest="build",
        help="Supply build meta data."
    )

    parser.add_argument(
        "--force",
        action="store_true",
        dest="force_it",
        help="By default, setting the major version resets minor and patch to 0, and setting minor resets patch to "
             "0. Use this switch to force the exact version that you specify."
    )

    parser.add_argument(
        "-M",
        "--major",
        action="store_true",
        dest="major",
        help="Increase the major version number when you make changes to the public API that are "
             "backward-incompatible."
    )

    parser.add_argument(
        "-m",
        "--minor",
        action="store_true",
        dest="minor",
        help="Increase the minor version number when new or updated functionality has been implemented "
             "that does not change the public API."
    )

    parser.add_argument(
        "-n=",
        "--name=",
        dest="name",
        help="Name your release."
    )

    parser.add_argument(
        "-p",
        "--patch",
        action="store_true",
        dest="patch",
        help="Set (or increase) the patch level when backward-compatible bug-fixes have been implemented."
    )

    parser.add_argument(
        "-P=",
        "--path=",
        default=PROJECT_HOME,
        dest="path",
        help="The path to where projects are stored. Defaults to %s" % PROJECT_HOME
    )

    parser.add_argument(
        "--preview",
        action="store_true",
        dest="preview_only",
        help="Preview the output, but don't make any changes."
    )

    parser.add_argument(
        "-s=",
        "--status=",
        dest="status",
        help="Use the status to denote a pre-release version."
    )

    parser.add_argument(
        "-T=",
        "--template=",
        dest="template",
        help="Path to the version.py template you would like to use. Use ? to see the default."
    )

    # Access to the version number requires special consideration, especially
    # when using sub parsers. The Python 3.3 behavior is different. See this
    # answer: http://stackoverflow.com/questions/8521612/argparse-optional-subparser-for-version
    # parser.add_argument('--version', action='version', version='%(prog)s 2.0')
    parser.add_argument(
        "-v",
        action="version",
        help="Show version number and exit.",
        version=__version__
    )
    parser.add_argument(
        "--version",
        action="version",
        help="Show verbose version information and exit.",
        version="%(prog)s" + " %s %s" % (__version__, __date__)
    )

    # This will display help or input errors as needed.
    args = parser.parse_args()
    # print args

    # Display the default version.py template.
    if args.template == "?":
        print(TEMPLATE)
        sys.exit(EXIT_OK)

    # Make sure the project root exists.
    project_name = args.project_name
    project_root = os.path.join(args.path, project_name)
    if not os.path.exists(project_root):
        print("Project does not exist: %s" % project_root)
        sys.exit(EXIT_INPUT)

    # Attempt to get the current version.
    version_txt = os.path.join(project_root, "VERSION.txt")
    if os.path.exists(version_txt):
        current_version = read_file(version_txt)
    else:
        current_version = "0.1.0-d"

    version_info = semver.parse_version_info(current_version)

    # Get updated version info from input, or (by default) display the current version.
    if args.major:
        new_version = semver.bump_major(current_version)
    elif args.minor:
        new_version = semver.bump_minor(current_version)
    elif args.patch:
        new_version = semver.bump_patch(current_version)
    else:
        print("%s %s" % (project_name, current_version))
        print sys.exit(EXIT_OK)

    # Set status.
    if args.status:
        new_version += "-%s" % args.status
    elif version_info.prerelease:
        new_version += "-%s" % version_info.prerelease
    else:
        pass

    # Set build.
    if args.build:
        new_version += "+%s" % args.build
    elif version_info.build:
        new_version += "+%s" % version_info.build

    # Write the VERSION.txt file.
    if args.preview_only:
        print("")
        print("Write '%s' to %s" % (new_version, version_txt))
        print("")
    else:
        write_file(version_txt, new_version)

    # Write the version.py file.
    tokens = semver.parse(new_version)
    tokens['now'] = NOW

    if args.name:
        tokens['name'] = args.name
    else:
        tokens['name'] = ""

    if tokens['build'] is None:
        tokens['build'] = ""

    if tokens['prerelease'] is None:
        tokens['prerelease'] = ""

    for p in VERSION_PY_LOCATIONS:
        version_py = p % {'project_name': project_name, 'project_root': project_root}
        # print version_py

        if os.path.exists(version_py):
            template = Template(args.template or TEMPLATE)
            content = template.substitute(**tokens)

            if args.preview_only:
                print("Write to %s " % version_py)
                print(content)
                print("-" * 79)
                print("")
            else:
                write_file(version_py, content)

    # Quit.
    sys.exit(EXIT_OK)


def check_root_path():
    """We must always run from the project root directory."""
    path = os.path.join("source", "manage.py")
    if not os.path.exists(path):
        print("Could not find %s -- are you in the project root?" % path)
        sys.exit(EXIT_USAGE)


def get_tokens(string):
    """Break apart the release string and return the tokens.

    :param string: The release to get parsed.
    :type string: str

    :rtype: dict
    :returns: Returns a dictionary with keys for: major, minor, patch, status

    """
    try:
        release, status = string.strip().split("-")
    except ValueError:
        release = string
        status = "d"

    tokens = release.split(".")

    if len(tokens) == 3:
        patch = tokens[2]
    else:
        patch = "0"

    if len(tokens) >= 2:
        minor = tokens[1]
    else:
        minor = "0"

    major = tokens[0]

    return {
        'major': major,
        'minor': minor,
        'patch': patch,
        'status': status,
    }


def read_file(path):
    """Get the contents of a file.

    :param path: The file to read.
    :type path: str

    :rtype: str

    """
    with open(path, "rb") as f:
        content = f.read()
        f.close()

        return content


def write_file(path, content):
    """Write a file, replacing its contents.

    :param path: The path to the file.
    :type path: str

    :param content: The content to write.
    :type content: str

    """
    with open(path, "wb") as f:
        f.write(content)
        f.close()

# Kickoff
if __name__ == "__main__":
    main()